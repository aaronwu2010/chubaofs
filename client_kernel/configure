#!/bin/sh

TMPDIR=$PWD/build
MAKEFILE="${TMPDIR}/Makefile"
TEST_H="${TMPDIR}/test.h"
TEST_C="${TMPDIR}/test.c"
CONFIG_LOG=$PWD/config.log
CONFIG_H=$PWD/config.h

check_flags() {
    make -C $TMPDIR >> $CONFIG_LOG 2>&1
    if [ $? -eq 0 ]
    then
        echo $1 "yes"
        echo "#define $1 1" >> $CONFIG_H
    else
        echo $1 "no"
    fi
    make -C $TMPDIR clean >> $CONFIG_LOG 2>&1
}

rm -rf $TMPDIR
mkdir -p $TMPDIR
rm -rf $CONFIG_LOG
rm -rf $CONFIG_H

echo "#ifndef __CONFIG_H__" >> $CONFIG_H
echo "#define __CONFIG_H__" >> $CONFIG_H

cat > $MAKEFILE <<EOF
EXTRA_CFLAGS += -Werror

obj-m += test.o
all:
	make -C /lib/modules/$(uname -r)/build M=$PWD/build modules
clean:
	make -C /lib/modules/$(uname -r)/build M=$PWD/build clean
EOF

cat > $TEST_H <<EOF
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL v2");
EOF

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

const char *get_link (struct dentry *dentry, struct inode *inode, struct delayed_call *call)
{
    return NULL;
}

int test (void)
{
    struct inode_operations op;

    op.get_link = get_link;
    return 0;
}

EOF
check_flags "KERNEL_HAS_GET_LINK"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int getattr (const struct path *path, struct kstat *stat, u32 mask, unsigned int flags)
{
    return 0;
}

int test (void)
{
    struct inode_operations op;

    op.getattr = getattr;
    return 0;
}

EOF
check_flags "KERNEL_HAS_GETATTR_WITH_PATH"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int rename (struct inode *old_dir, struct dentry *old_dentry,
			struct inode *new_dir, struct dentry *new_dentry, unsigned int flags)
{
    return 0;
}

int test (void)
{
    struct inode_operations op;

    op.rename = rename;
    return 0;
}

EOF
check_flags "KERNEL_HAS_RENAME_WITH_FLAGS"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int iterate (struct file *file, struct dir_context *ctx)
{
    return 0;
}

int test (void)
{
    struct file_operations op;

    op.iterate = iterate;
    return 0;
}

EOF
check_flags "KERNEL_HAS_ITERATE_DIR"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int iterate_shared (struct file *file, struct dir_context *ctx)
{
    return 0;
}

int test (void)
{
    struct file_operations op;

    op.iterate_shared = iterate_shared;
    return 0;
}

EOF
check_flags "KERNEL_HAS_ITERATE_DIR_SHARED"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

ssize_t read_iter (struct kiocb *iocb, struct iov_iter *iov)
{
    return 0;
}

ssize_t write_iter (struct kiocb *iocb, struct iov_iter *iov)
{
    return 0;
}

int test (void)
{
    struct file_operations op;

    op.read_iter = read_iter;
    op.write_iter = write_iter;
    return 0;
}

EOF
check_flags "KERNEL_HAS_READ_WRITE_ITER"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

ssize_t direct_IO (struct kiocb *iocb, struct iov_iter *iter)
{
    return 0;
}

int test (void)
{
    struct address_space_operations op;

    op.direct_IO = direct_IO;
    return 0;
}

EOF
check_flags "KERNEL_HAS_DIO_WITH_ITER"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

ssize_t direct_IO (struct kiocb *iocb, struct iov_iter *iter, loff_t offset)
{
    return 0;
}

int test (void)
{
    struct address_space_operations op;

    op.direct_IO = direct_IO;
    return 0;
}

EOF
check_flags "KERNEL_HAS_DIO_WITH_ITER_AND_OFFSET"

cat > $TEST_C <<EOF
#include <linux/uio.h>
#include "test.h"

int test (void)
{
    struct iov_iter iter;

    iov_iter_init(&iter, 0, NULL, 0, 0);
    return 0;
}

EOF
check_flags "KERNEL_HAS_IOV_ITER_WITH_TAG"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int test (void)
{
    setattr_prepare(NULL, NULL);
    return 0;
}

EOF
check_flags "KERNEL_HAS_SETATTR_PREPARE"

cat > $TEST_C <<EOF
#include <linux/net.h>
#include <linux/socket.h>
#include <linux/in.h>
#include <net/net_namespace.h>
#include "test.h"

int test (void)
{
    return sock_create_kern(&init_net, AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL);
}

EOF
check_flags "KERNEL_HAS_SOCK_CREATE_KERN_WITH_NET"

cat > $TEST_C <<EOF
#include <linux/uio.h>
#include "test.h"

int test (void)
{
    const struct iov_iter *iter = NULL;
    iov_iter_iovec(iter);
    return 0;
}

EOF
check_flags "KERNEL_HAS_IOV_ITER_IOVEC"

cat > $TEST_C <<EOF
#include <linux/uio.h>
#include "test.h"

int test (void)
{
    struct iov_iter *i = NULL;
    unsigned int direction = 0;
    const struct iovec *iov = NULL;
    unsigned long nr_segs = 0;
    size_t count = 0;

    iov_iter_init(i, direction, iov, nr_segs, count);
    return 0;
}

EOF
check_flags "KERNEL_HAS_IOV_ITER_INIT_DIR"

cat > $TEST_C <<EOF
#include <linux/uio.h>
#include "test.h"

int test (void)
{
    const struct iov_iter *i = NULL;

    iter_is_iovec(i);
    return 0;
}

EOF
check_flags "KERNEL_HAS_ITER_BVEC"

cat > $TEST_C <<EOF
#include <linux/uio.h>
#include "test.h"

int test (void)
{
    void *addr = NULL;
    size_t bytes = 0;
    struct iov_iter *i = NULL;
    size_t ret;

    ret = copy_from_iter(addr, bytes, i);
    ret = copy_to_iter(addr, bytes, i);
    return 0;
}

EOF
check_flags "KERNEL_HAS_COPY_FROM_ITER"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include <linux/uio.h>
#include "test.h"

int test (void)
{
    struct iov_iter *i = NULL;
    size_t count = 0;

    iov_iter_truncate(i, count);
    return 0;
}

EOF
check_flags "KERNEL_HAS_IOV_ITER_TRUNCATE"

cat > $TEST_C <<EOF
#include <rdma/ib_verbs.h>
#include "test.h"

int test (void)
{
    struct ib_cq *cq = NULL;
    struct ib_udata *udata = NULL;

    ib_destroy_cq_user(cq, udata);
    return 0;
}

EOF
check_flags "KERNEL_HAS_IB_DESTROY_CQ_USER"

cat > $TEST_C <<EOF
#include <rdma/rdma_cm.h>
#include "test.h"

int test (void)
{
    struct rdma_cm_id *id = NULL;
    const void *private_data = NULL;
    u8 private_data_len = 0;
    u8 reason = 0;

    rdma_reject(id, private_data, private_data_len, reason);
    return 0;
}

EOF
check_flags "OFED_RDMA_REJECT_NEEDS_REASON"

cat > $TEST_C <<EOF
#include <linux/printk.h>
#include "test.h"

int test (void)
{
    pr_warn("test print");
    return 0;
}

EOF
check_flags "KERNEL_SUPPORT_PR_WARN"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include <linux/user_namespace.h>
#include "test.h"

int test (void)
{
    struct user_namespace *ns = NULL;
    struct inode *inode = NULL;
    int mask = 0;

    return generic_permission(ns, inode, mask);
}

EOF
check_flags "KERNEL_HAS_NAMESPACE"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int test (void)
{
    struct super_block *sb = NULL;
    return super_setup_bdi_name(sb, "test");
}

EOF
check_flags "KERNEL_HAS_SUPER_SETUP_BDI_NAME"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int test (void)
{
    return SB_POSIXACL;
}

EOF
check_flags "KERNEL_HAS_SB_POSIXACL"

cat > $TEST_C <<EOF
#include <linux/proc_fs.h>
#include "test.h"

int test (void)
{
    struct proc_ops ops;
    ops.proc_flags = 0;
    return 0;
}

EOF
check_flags "KERNEL_HAS_PROC_OPS"

cat > $TEST_C <<EOF
#include <crypto/hash.h>
#include "test.h"

int test (void)
{
    struct shash_desc desc;
    desc.flags = 0;
    return 0;
}

EOF
check_flags "KERNEL_SHASH_DESC_FLAGS"

cat > $TEST_C <<EOF
#include <net/sock.h>
#include "test.h"

int test (void)
{
    struct socket *sock = NULL;
    int level = 0;
    int op = 0;
    sockptr_t optval;
    unsigned int optlen = 0;
    return sock_setsockopt(sock, level, op, optval, optlen);
}

EOF
check_flags "KERNEL_HAS_SOCK_SETSOCKOPT"

cat > $TEST_C <<EOF
#include <linux/sockptr.h>
#include "test.h"

int test (void)
{
    return 0;
}

EOF
check_flags "KERNEL_HAS_SOCKPTR"

cat > $TEST_C <<EOF
#include <linux/time.h>
#include <linux/timex.h>
#include "test.h"

int test (void)
{
    struct tm result;
    time64_to_tm(0, 0, &result);
    return 0;
}

EOF
check_flags "KERNEL_HAS_TIME64_TO_TM"

cat > $TEST_C <<EOF
#include <linux/time.h>
#include <linux/timex.h>
#include "test.h"

int test (void)
{
    mktime64(2024, 1, 22, 0, 0, 0);
    return 0;
}

EOF
check_flags "KERNEL_HAS_MKTIME64"

cat > $TEST_C <<EOF
#include <linux/time.h>
#include <linux/timex.h>
#include "test.h"

int test (void)
{
    switch(1) {
        case 0:
        fallthrough;
        case 1:
        fallthrough;
        default:
        return 0;
    }
    return 0;
}

EOF
check_flags "KERNEL_SUPPORT_SWITCH_FALLTHROUGH"

cat > $TEST_C <<EOF
#include <rdma/rdma_cm.h>
#include "test.h"

int test (void)
{
    struct rdma_cm_id *new_cm_id;
	new_cm_id = rdma_create_id(&init_net, NULL, NULL,
				   RDMA_PS_TCP, IB_QPT_RC);
    return 0;
}

EOF
check_flags "OFED_HAS_NETNS"

cat > $TEST_C <<EOF
#include <rdma/ib_verbs.h>
#include "test.h"

int test (void)
{
    struct rdma_cm_id *new_cm_id;
	new_cm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP,
				   IB_QPT_RC);
    return 0;
}

EOF
check_flags "OFED_HAS_RDMA_CREATE_QPTYPE"

cat > $TEST_C <<EOF
#include <rdma/rdma_cm.h>
#include "test.h"

void event_handler(struct ib_event *ie, void *v) {
}

void comp_handler(struct ib_cq *cq, void *cq_context) {

}

int test (void)
{
	struct ib_cq_init_attr attrs = {
		.cqe = 0,
		.comp_vector = 0,
	};
    struct ib_cq *cq = NULL;
    struct ib_device *device = NULL;
    //ib_comp_handler comp_handler;
	//void (*event_handler)(struct ib_event *, void *);
    void *cq_context = NULL;

	cq = ib_create_cq(device, comp_handler, event_handler, cq_context,
			    &attrs);
    return 0;
}

EOF
check_flags "OFED_HAS_IB_CREATE_CQATTR"

cat > $TEST_C <<EOF
#include "test.h"

int test (void)
{
    struct inode *inode = NULL;
    void *data = NULL;
    data = PDE_DATA(inode)
    return 0;
}

EOF
check_flags "KERNEL_HAS_PDE_DATA"

cat > $TEST_C <<EOF
#include "test.h"

int test (void)
{
    struct folio item;
    struct folio *fl = NULL;
    fl = &item;
    return 0;
}

EOF
check_flags "KERNEL_HAS_FOLIO"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int cfs_write_begin_test(struct file *file, struct address_space *mapping,
			   loff_t pos, unsigned len,
			   struct page **pagep, void **fsdata) {
    return 0;
}

int test (void)
{
    struct address_space_operations cfs_test_ops = {
        .write_begin = cfs_write_begin_test,
    };
    
    return cfs_test_ops.write_begin(NULL, NULL, 0, 0, NULL, NULL);
}

EOF
check_flags "KERNEL_WRITE_GEGIN_NO_FLAGS"

cat > $TEST_C <<EOF
#include <linux/fs.h>
#include "test.h"

int cfs_readpage_test(struct file *file, struct page *page) {
    return 0;
}

int test (void)
{
    struct address_space_operations cfs_test_ops = {
        .readpage = cfs_readpage_test,
    };

    return cfs_test_ops.readpage(NULL, NULL);
}

EOF
check_flags "KERNEL_READ_PAGE"

echo "#endif" >> $CONFIG_H
rm -rf $TMPDIR
